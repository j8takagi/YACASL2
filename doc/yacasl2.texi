\input texinfo   @c -*-texinfo-*-
@c %**start of header
@ifnottex
@documentlanguage ja_JP
@end ifnottex
@setfilename yacasl2.info
@settitle YACASL2 - Linux上のCASL II処理系
@firstparagraphindent insert
@paragraphindent 1
@c %**end of header

@copying
Copyright @copyright{} 2010 j8takagi
@end copying

@exampleindent 2

@dircategory Basics
@direntry
* YACASL2: (yacasl2).
@end direntry

@titlepage
@title YACASL2
@subtitle Linux上のCASL II処理系
@author j8takagi
@insertcopying
@end titlepage

@ifnottex
@node Top
@end ifnottex

@menu
* YACASL2の概要::
* YACASL2のインストール::
* YACASL2の使い方::
* YACASL2コマンドマニュアル::
@end menu

@contents

@node YACASL2の概要, YACASL2のインストール, Top, Top
@chapter YACASL2の概要

YACASL2は、Linux上で動作するオープンソースのCASL II処理系です。CASL IIは情報処理試験で用いられるアセンブラ言語で、次の資料により仕様が公開されています。

@iftex
@cartouche
@end iftex
@quotation
@uref{http://www.jitec.ipa.go.jp/1_00topic/topic_20081027_hani_yougo.pdf, 試験で使用する情報処理用語・プログラム言語など（2008年10月版）}［PDFファイル］
別紙 1 アセンブラ言語の仕様
@end quotation
@iftex
@end cartouche
@end iftex

YACASL2は、CASL IIアセンブラ言語で記述されたファイルをアセンブルし、仮想マシンCOMET II上で実行します。アセンブルと実行は、連続で行うことも別々に行うことも可能です。
YACASL2の動作はCASL IIの仕様に準拠しているため、情報処理試験の問題をはじめ各種参考書やサイトに記載されたCASL IIのプログラムをそのままアセンブルして実行できます。また、本パッケージ中にCASL IIのサンプルプログラムが多数収録されています。

YACASL2は、「ふつうの処理系」として動作します。ほかの多くのCASL IIエミュレータと違い、デバッガとして動作したり、コンピュータ内部の模式図を表示したりすることはありません。そのかわり、YACASL2は、次のような動作内容をすべてテキストで出力します。

@itemize @bullet

@item
ラベルとアドレスの対応

@item
アセンブル結果

@item
実行時のレジスタの内容

@item
実行時のメモリの内容
@end itemize

出力された動作内容は、GNU/Linuxのさまざまなツール、たとえば@command{cat}、@command{less}、@command{grep}、@command{wc}などを使って解析できます。

YACASL2の操作は、端末を開いてコマンドを入力・実行することで行います。

@unnumberedsec 要件
YACASL2は、Linux上で動作します。現在動作を確認しているのは、次のディストリビューションです。

@itemize @bullet

@item
Ubuntu Linux 9.04 / 8.04

@item
Vine Linux 4.2
@end itemize

インストール時に、@command{tar}、@command{gcc}、@command{make}が必要です。

@node YACASL2のインストール, YACASL2の使い方, YACASL2の概要, Top
@chapter YACASL2のインストール
YACASL2をインストールするには、Linux上で次の作業をします。

@enumerate

@item
@file{yacasl2.tar.gz}のダウンロード

@item
@file{yacasl2.tar.gz}の検証

@item
@file{yacasl2.tar.gz}の展開

@item
@command{casl2}、@command{comet2}、@command{dumpword}のビルド

@item
@command{casl2}の実行テスト

@item
詳細なテスト

@item
環境変数@var{PATH}の設定
@end enumerate

@section @file{yacasl2.tar.gz}のダウンロード
（詳細未定）

@iftex
@cartouche
@end iftex
@example
$ @command{cd}
$ @command{wget somewhere/yacasl2.tar.gz}
$ @command{wget somewhere/yacasl2.tar.gz.md5sum}
@end example
@iftex
@end cartouche
@end iftex

@section @file{yacasl2.tar.gz}の検証

（PGPを使った検証も導入予定）

ダウンロードが完了したら、@command{md5sum}と@command{diff}で正しくファイルがダウンロードができているかを検証します。

@iftex
@cartouche
@end iftex
@example
$ @command{md5sum yacasl2.tar.gz | diff -s yacasl2.tar.gz.md5sum -}
Files yacasl2.tar.gz.md5sum and - are identical
@end example
@iftex
@end cartouche
@end iftex

@section @file{yacasl2.tar.gz}の展開

@file{yacasl2.tar.gz}をダウンロードしたら、次のコマンドで展開します。

@iftex
@cartouche
@end iftex
@example
$ @command{tar xvzf yacasl2.tar.gz}
@end example
@iftex
@end cartouche
@end iftex

@section @command{casl2}、@command{comet2}、@command{dumpword}のビルド

展開したら、次のコマンドで@command{casl2}、@command{comet2}、@command{dumpword}をビルドします。

@iftex
@cartouche
@end iftex
@example
$ @command{cd yacasl2}
$ @command{make}
make -C src
make[1]: Entering directory ‘/home/kazubito/yacasl2/src’
gcc -c -g -Wall -I ../include casl2.c
gcc -c -g -Wall -I ../include word.c
gcc -c -g -Wall -I ../include hash.c
gcc -c -g -Wall -I ../include cerr.c
gcc -c -g -Wall -I ../include struct.c
gcc -c -g -Wall -I ../include cmd.c
gcc -c -g -Wall -I ../include assemble.c
gcc -c -g -Wall -I ../include token.c
gcc -c -g -Wall -I ../include label.c
gcc -c -g -Wall -I ../include macro.c
gcc -c -g -Wall -I ../include exec.c
gcc -c -g -Wall -I ../include dump.c
gcc -g -Wall -I ../include -o ../casl2 casl2.o word.o hash.o cerr.o st
ruct.o cmd.o assemble.o token.o label.o macro.o exec.o dump.o
gcc -c -g -Wall -I ../include comet2.c
gcc -g -Wall -I ../include -o ../comet2 comet2.o word.o hash.o cerr.o
struct.o cmd.o exec.o dump.o
gcc -c -g -Wall -I ../include dumpword.c
gcc -g -Wall -I ../include -o ../dumpword dumpword.o word.o cerr.o
make[1]: Leaving directory ‘/home/kazubito/yacasl2/src’
@end example
@iftex
@end cartouche
@end iftex

@section @command{casl2}の実行テスト

ビルドしたら、次のコマンドが正常に実行できるかを確認します。
正常に実行された場合は、「Hello, World!」と表示されます。

@iftex
@cartouche
@end iftex
@example
$ @command{./casl2 as/hello.casl}
Hello, World!
@end example
@iftex
@end cartouche
@end iftex

@section 詳細なテスト

次のコマンドを実行すると、正常にビルドできているかどうかを詳細にテストできます。

@iftex
@cartouche
@end iftex
@example
$ @command{make check}
194 / 194 tests passed. Details in /home/kazubito/yacasl2/test/integra
tion/casl2/Test.log
All tests are succeded.
149 / 149 tests passed. Details in /home/kazubito/yacasl2/test/integra
tion/comet2/Test.log
All tests are succeded.
4 / 4 tests passed. Details in /home/kazubito/yacasl2/test/integration
/dumpword/Test.log
All tests are succeded.
@end example
@iftex
@end cartouche
@end iftex

@section 環境変数@var{PATH}の設定

環境変数@var{PATH}にYACASL2のディレクトリを追加すると、どのディレクトリでも@command{casl2}、@command{comet2}、@command{dumpword}を実行できます。

環境変数の設定方法は使っているシェルによって異なります。シェルは、次のコマンドで確認できます。

@iftex
@cartouche
@end iftex
@example
$ @command{echo $SHELL}
/bin/bash
@end example
@iftex
@end cartouche
@end iftex

現在もっとも多く使われているシェルは、BASHでしょう。BASHでは、次のコマンドを実行すると環境変数@var{PATH}にYACASL2のディレクトリが追加されます。

@iftex
@cartouche
@end iftex
@example
$ @command{PATH=$PATH:~/yacasl2 && export PATH}
@end example
@iftex
@end cartouche
@end iftex

シェルの初期設定ファイルに上記のコマンドを追加すれば、今後ログインした後は自動的にどのディレクトリでも @command{casl2}、@command{comet2}、@command{dumpword}を実行できます。BASHではホームディレクトリにある@file{.bashrc}が初期設定ファイルのため、次のコマンドで追加されます。

@iftex
@cartouche
@end iftex
@example
$ @command{echo ’PATH=$PATH:~/yacasl2 && export PATH’ >>~/.bashrc}
@end example
@iftex
@end cartouche
@end iftex

@node YACASL2の使い方, YACASL2コマンドマニュアル, YACASL2のインストール, Top
@chapter YACASL2 の使い方
YACASL2 は、テキストファイルに記述されたCASLプログラムを処理します。以下の例で用いられるCASLプログラムのファイルは、テキストエディタなどで作成してください。また、インストールしたディレクトリの中にある@file{as}ディレクトリからコピーして作成することもできます。

@section 実行結果の出力だけを表示

インストール時にコマンド実行の確認に使った@file{hello.casl}は、次のような内容です。CASL IIのマクロ命令OUTは、文字列を出力します。

@iftex
@cartouche
@end iftex
@example
$ @command{cat hello.casl}
MAIN     START
         OUT     OBUF,LEN
         RET
OBUF     DC      ’Hello, World!’
LEN      DC      13
         END
@end example
@iftex
@end cartouche
@end iftex

次のコマンドを実行すると、CASL II のアセンブルと仮想マシン COMET II 上での実行が連続で行われ、文字列が出力されます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 hello.casl}
Hello, World!
@end example
@iftex
@end cartouche
@end iftex

@file{addl.casl}は、3と1の和を求めます。

@iftex
@cartouche
@end iftex
@example
$ @command{cat addl.casl}
;;; ADDL r,adr
MAIN     START
         LD      GR1,A
         ADDL    GR1,B
         RET
A        DC      3
B        DC      1
         END
@end example
@iftex
@end cartouche
@end iftex

このプログラムには出力命令がないため、オプションなしで実行した場合には結果が出力されません。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 addl.casl}
$
@end example
@iftex
@end cartouche
@end iftex

実行内容を確認するには、後述のようにCPU 内にあるレジスタやメモリの内容を表示するか、結果を出力するための処理を追加する必要があります。

@file{sum_10.casl}は、1から10までの整数の和を求めます。

@iftex
@cartouche
@end iftex
@example
$ @command{cat sum_10.casl}
;;; sum_10.casl
;;; 出力 GR0: 1から10までの整数をすべて加算した値
MAIN    START
        PUSH    0,GR1
        LAD     GR0,0           ; GR0を初期化
        LD      GR1,FST         ; GR1に初項を転送
LOOP    ADDL    GR0,GR1         ; ループ先頭
        ADDL    GR1,STEP        ; GR1 <- GR1 + 公差
        CPL     GR1,LST         ; GR1が末項より大きい場合は終了
        JPL     FIN             ; ↓
        JUMP    LOOP            ; ループ終端
FIN     POP     GR1
        RET
FST     DC      1               ; 初項
LST     DC      10              ; 末項
STEP    DC      1               ; 公差
        END
@end example
@iftex
@end cartouche
@end iftex

このプログラムも、オプションなしで実行した場合には結果が出力されません。
@iftex
@cartouche
@end iftex
@example
$ @command{casl2 sum_10.casl}
$
@end example
@iftex
@end cartouche
@end iftex

@section アセンブル結果の確認
casl2の処理途中で行われるアセンブルの結果を表示するには、オプション@option{-a}を指定します。また、ラベルとアドレスの対応表を表示するには、オプション@option{-l}を指定します。

次のコマンドでは@file{hello.casl}の、ラベルとアドレスの対応表と、アセンブル結果と、実行結果が表示されます。OUTはアセンブラ命令で複数の機械語命令で構成されているため、命令行1行に対して、複数行のコードが生成されます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -a -l hello.casl}

Assemble hello.casl (0)

Label::::
MAIN.LEN ---> #0020
MAIN ---> #0000
MAIN.OBUF ---> #0013

Assemble hello.casl (1)
hello.casl:    1:MAIN    START
hello.casl:    2:        OUT     OBUF,LEN
    #0000   #7001
    #0001   #0000
    #0002   #7002
    #0003   #0000
    #0004   #1210
    #0005   #0013
    #0006   #1220
    #0007   #0020
    #0008   #F000
    #0009   #0002
    #000A   #1210
    #000B   #0021
    #0021   #000A
    #000C   #1220
    #000D   #0022
    #0022   #0001
    #000E   #F000
    #000F   #0002
    #0010   #7120
    #0011   #7110
hello.casl:    3:        RET
    #0012   #8100
hello.casl:    4:OBUF    DC      'Hello, World!'
    #0013   #0048
    #0014   #0065
    #0015   #006C
    #0016   #006C
    #0017   #006F
    #0018   #002C
    #0019   #0020
    #001A   #0057
    #001B   #006F
    #001C   #0072
    #001D   #006C
    #001E   #0064
    #001F   #0021
hello.casl:    5:LEN     DC      13
    #0020   #000D
hello.casl:    6:        END
Hello, World!
@end example
@iftex
@end cartouche
@end iftex

@file{addl.casl}の、ラベルとアドレスの対応表と、アセンブル結果は、次のようになります。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -a -l addl.casl}

Assemble addl.casl (0)

Label::::
MAIN.A ---> #0005
MAIN.B ---> #0006
MAIN ---> #0000

Assemble addl.casl (1)
addl.casl:    1:;;; ADDL r,adr
addl.casl:    2:MAIN    START
addl.casl:    3:        LD      GR1,A
    #0000   #1010
    #0001   #0005
addl.casl:    4:        ADDL    GR1,B
    #0002   #2210
    #0003   #0006
addl.casl:    5:        RET
    #0004   #8100
addl.casl:    6:A       DC      3
    #0005   #0003
addl.casl:    7:B       DC      1
    #0006   #0001
addl.casl:    8:        END
@end example
@iftex
@end cartouche
@end iftex

なお、オプション@option{-A}を指定すると、アセンブル結果が表示される時点で処理が終了します。仮想マシンCOMET II での実行は行われません。

@section 実行時のレジスタとメモリを表示
YACASL2では実行中のCPUのレジスタとメモリの内容をそれぞれ、@option{-t}と@option{-d}を指定することで表示できます。

また、@option{-M}で、仮想マシンCOMET II のメモリ容量を語(16 ビット)単位で指定できます。小さいプログラムを実行するときは、メモリ容量を小さくすれば結果が見やすくなります。

@file{addl.casl}に必要なメモリ容量は8語のため、次のようにCPUのレジスタとメモリの内容を表示できます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t -d -M8 addl.casl | less}

Assemble addl.casl (0)

Assemble addl.casl (1)

Executing machine codes
#0000: Register::::
#0000: GR0:      0 = #0000 = 0000000000000000
#0000: GR1:      0 = #0000 = 0000000000000000
#0000: GR2:      0 = #0000 = 0000000000000000
#0000: GR3:      0 = #0000 = 0000000000000000
#0000: GR4:      0 = #0000 = 0000000000000000
#0000: GR5:      0 = #0000 = 0000000000000000
#0000: GR6:      0 = #0000 = 0000000000000000
#0000: GR7:      0 = #0000 = 0000000000000000
#0000: SP:       8 = #0008 = 0000000000001000
#0000: PR:       0 = #0000 = 0000000000000000
#0000: FR (OF SF ZF): 000
#0000: Memory::::
#0000: adr : 0000 0001 0002 0003 0004 0005 0006 0007
#0000: 0000: 1010 0005 2210 0006 8100 0003 0001 0000 
#0002: Register::::
#0002: GR0:      0 = #0000 = 0000000000000000
#0002: GR1:      3 = #0003 = 0000000000000011
#0002: GR2:      0 = #0000 = 0000000000000000
#0002: GR3:      0 = #0000 = 0000000000000000
#0002: GR4:      0 = #0000 = 0000000000000000
#0002: GR5:      0 = #0000 = 0000000000000000
#0002: GR6:      0 = #0000 = 0000000000000000
#0002: GR7:      0 = #0000 = 0000000000000000
#0002: SP:       8 = #0008 = 0000000000001000
#0002: PR:       2 = #0002 = 0000000000000010
#0002: FR (OF SF ZF): 000
#0002: Memory::::
#0002: adr : 0000 0001 0002 0003 0004 0005 0006 0007
#0002: 0000: 1010 0005 2210 0006 8100 0003 0001 0000 
#0004: Register::::
#0004: GR0:      0 = #0000 = 0000000000000000
#0004: GR1:      4 = #0004 = 0000000000000100
#0004: GR2:      0 = #0000 = 0000000000000000
#0004: GR3:      0 = #0000 = 0000000000000000
#0004: GR4:      0 = #0000 = 0000000000000000
#0004: GR5:      0 = #0000 = 0000000000000000
#0004: GR6:      0 = #0000 = 0000000000000000
#0004: GR7:      0 = #0000 = 0000000000000000
#0004: SP:       8 = #0008 = 0000000000001000
#0004: PR:       4 = #0004 = 0000000000000100
#0004: FR (OF SF ZF): 000
#0004: Memory::::
#0004: adr : 0000 0001 0002 0003 0004 0005 0006 0007
#0004: 0000: 1010 0005 2210 0006 8100 0003 0001 0000 
@end example
@iftex
@end cartouche
@end iftex

@subsection 特定のレジスタを表示

@file{addl.casl}のレジスタやメモリの中で、実行中に値が変化しているのはGR1だけです。こうした場合は、@command{grep}を使って表示される内容を絞り込むことで動作を検証しやすくなります。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t addl.casl | grep 'GR1:'}
#0000: GR1:      0 = #0000 = 0000000000000000
#0002: GR1:      3 = #0003 = 0000000000000011
#0004: GR1:      4 = #0004 = 0000000000000100
@end example
@iftex
@end cartouche
@end iftex

この内容を、先に出力したアセンブル結果と引き比べてください。
次の表のように、PRとGR1、命令行が対応していることがわかります。

@multitable @columnfractions .3 .3 .4
@item PR @tab GR1 @tab 命令行
@item #0000
@tab #0000
@item #0002
@tab #0003
@tab @code{LD GR1,A}
@item #0004
@tab #0004
@tab @code{ADDL GR1,B}
@end multitable

@subsection プログラム終了時の値を表示

@command{grep}と@command{tail}を組み合わせれば、プログラム終了時の値を表示できます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t addl.casl | grep 'GR1:' | tail -1}
#0004: GR1:      4 = #0004 = 0000000000000100
@end example
@iftex
@end cartouche
@end iftex

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t sum_10.casl | grep 'GR0:' | tail -1}
#0010: GR0:     55 = #0037 = 0000000000110111 = '7'
@end example
@iftex
@end cartouche
@end iftex

@subsection プログラムのステップ数を表示

@command{grep}と@command{wc}を組み合わせれば、プログラムのステップ数を表示できます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t hello.casl | grep 'GR1:' | wc -l}
11
@end example
@iftex
@end cartouche
@end iftex

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t addl.casl | grep 'GR1:' | wc -l}
3
@end example
@iftex
@end cartouche
@end iftex

@file{sum_10.casl}はプログラム内にループがあるため、ステップ数が大きくなります。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -t sum_10.casl | grep 'GR0:' | wc -l}
54
@end example
@iftex
@end cartouche
@end iftex

@section アセンブルと実行を別に行う

@command{casl2}に@option{-O}@file{ファイル名}を指定すると、オブジェクトファイルを作成できます。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 -Ohello.o hello.casl}
@end example
@iftex
@end cartouche
@end iftex

作成されたオブジェクトファイルの内容は、@command{od}を使って確認できます。テキストファイルではないため、@command{cat}などでは確認できません。

@iftex
@cartouche
@end iftex
@example
$ @command{od -t x2 hello.o}
0000000 7001 0000 7002 0000 1210 0013 1220 0020
0000020 f000 0002 1210 0021 1220 0022 f000 0002
0000040 7120 7110 8100 0048 0065 006c 006c 006f
0000060 002c 0020 0057 006f 0072 006c 0064 0021
0000100 000d 000a 0001
0000106
@end example
@iftex
@end cartouche
@end iftex

オブジェクトファイルの実行には、@command{comet2}を使います。

@iftex
@cartouche
@end iftex
@example
$ @command{comet2 hello.o}
Hello, World!
@end example
@iftex
@end cartouche
@end iftex

@section 1語の解析

CASL IIでは、1語（16ビット）を単位としてデータが処理されます。
@command{dumpword}は、指定した1語を10進数、16進数、2進数で表示します。

@iftex
@cartouche
@end iftex
@example
$ @command{dumpword 72}
    72:     72 = #0048 = 0000000001001000 = 'H'
@end example
@iftex
@end cartouche
@end iftex

マイナスの数は、次のように指定します。

@iftex
@cartouche
@end iftex
@example
$ @command{dumpword} @option{--} @command{-72}
   -72:    -72 = #FFB8 = 1111111110111000
@end example
@iftex
@end cartouche
@end iftex

16進数は、次のように指定します。

@iftex
@cartouche
@end iftex
@example
$ @command{dumpword '#0048'}
 #0048:     72 = #0048 = 0000000001001000 = 'H'
@end example
@iftex
@end cartouche
@end iftex

@section CASL2ライブラリの使用

YACASL2の@file{as/casl2lib}ディレクトリには、CASL IIで記述されたライブラリファイルが格納されています。

このフォルダには、たとえば次のようなプログラムが含まれています。

@table @samp
@item OUTL
@file{outl.casl}。GR1に格納された値を、0〜65535の数値として出力します。

@item OUTA
@file{outa.casl}。GR1に格納された値を、-32767〜32767の数値として出力します。

@item MULL
@file{mull.casl}。GR1とGR2に格納された値を0〜65535の整数と見なし、積をGR3に格納します。

@item DIVL
@file{divl.casl}。GR1とGR2に格納された値を0〜65535の整数と見なし、商をGR3、剰余をGR0に格納します。
@end table

@subsection 数値を出力する

3と1の和を求める@file{addl.casl}で演算結果を出力するには、まず@file{addl.casl}を編集します。CASL IIの@command{CALL}命令で@command{OUTL}を副プログラムとして呼び出すようにします。

@iftex
@cartouche
@end iftex
@example
$ @command{cat addl_outl.casl}
MAIN    START
        LD      GR1,A
        ADDL    GR1,B
        @strong{CALL    OUTL}
        RET
A       DC      3
B       DC      1
        END
@end example
@iftex
@end cartouche
@end iftex

変更したら@command{casl2}を、複数のファイルを指定して実行します。

@iftex
@cartouche
@end iftex
@example
$ @command{casl2 addl_outl.casl ~/yacasl2/as/casl2lib/outl.casl}
4
@end example
@iftex
@end cartouche
@end iftex

@node YACASL2コマンドマニュアル,, YACASL2の使い方, Top
@chapter YACASL2コマンドマニュアル

@cindex YACASL2コマンドマニュアル

YACASL2のコマンドとオプションについて解説します。

@menu
* casl2::
* comet2::
* dumpword::
@end menu

@node casl2
@section @command{casl2}

@pindex casl2
@cindex casl2

@command{casl2}は、引数として指定されたCASLファイルをアセンブルし、仮想マシンCOMET II上で実行します。CASLファイルは、アセンブラ言語CASL IIで記述されたテキストファイルです。引数が指定されない場合は、エラーメッセージを表示して終了します。

@example
$ @command{casl2 hello.casl}
@end example

副プログラムを呼び出す場合は、複数のCASLファイルを指定することもできます。

@example
$ @command{casl2 addl_outl.casl ~/yacasl2/as/casl2lib/outl.casl}
@end example

@unnumberedsubsec オプション

@command{casl2}は、次のオプションを指定できます。

@table @samp
@item -s
@itemx --source
CASLファイルの内容を表示します。

@item -l
@itemx --label
ラベルの一覧を表示し、ほかの作業を続行します。

@item -L
@itemx --labelonly
ラベルの一覧を表示して終了します。

@item -a
@itemx --assembledetail
アセンブル詳細結果を表示し、ほかの作業を続行します。

@item -A
@itemx --show-all
アセンブル詳細結果を表示して終了します。

@item -o<OBJECTFILE>
@itemx --assembleout
アセンブル結果をオブジェクトファイル@file{<OBJECTFILE>}に出力し、ほかの作業を続行します。出力されたオブジェクトファイルは、@command{comet2}で実行できます。オブジェクトファイルを指定しない場合、出力先は@file{a.o}です。オブジェクトファイルは1つだけ指定できます。

@item -O<OBJECTFILE>
@itemx --assembleoutonly
アセンブル結果をオブジェクトファイル@file{<OBJECTFILE>}に出力し、終了します。出力されたオブジェクトファイルは、@command{comet2}で実行できます。オブジェクトファイルを指定しない場合、出力先は@file{a.o}です。オブジェクトファイルは1つだけ指定できます。

@item -t
@itemx --trace
@itemx --tracearithmetic
実行時のレジスタをトレースします。レジスタには、GR0〜GR7という8個の汎用レジスタと、SP（スタックポインタ）、PR（プログラムレジスタ）、FR（フラグレジスタ）があります。レジストリの内容は、-32,768〜32,767の範囲の整数、#0000〜#FFFFの範囲の16進数、2進数で表示されます。文字の組に該当する場合は、「 = 」のうしろに文字が表示されます。-32768〜32767の範囲の整数を表示するので、算術演算の結果を確認する場合に使えます。

@item -T
@itemx --tracelogical
@option{-t}と同じく、実行時のレジスタをトレースします。@option{-t}と異なり0〜65,535の範囲の整数を表示するので、論理演算の結果を確認する場合に使えます。

@item -d
@itemx --dump
メモリの内容をすべて表示します。

@item -M <MEMORYSIZE>
@itemx --memorysize <MEMORYSIZE>
アセンブルおよび実行時のメモリサイズ@option{<MEMORYSIZE>}を0〜65,535の範囲で指定します。指定しない場合、メモリサイズは512です。

@item -C <CLOCKS>
@itemx --clocks <CLOCKS>
実行時のクロック周波数@option{<CLOCKS>}を0より大きい整数で指定します。指定しない場合、クロック周波数は5000000です。

@item -h
@itemx --help
@command{casl2}の使用方法を表示して終了します。
@end table

@node comet2
@section @command{comet2}

@pindex comet2
@cindex comet2

@command{comet2}は、引数として指定されたオブジェクトファイルを仮想マシンCOMET II上で実行します。オブジェクトファイルは、@command{casl}に@option{-o}または@option{-O}を指定して出力します。

@example
$ @command{comet2 hello.o}
@end example

引数で指定できるオブジェクトファイルは1つだけです。引数が指定されない場合は、エラーメッセージを表示して終了します。複数の引数を指定した場合、2番目以降の引数は無視されます。

@unnumberedsubsec オプション

@command{comet2}は、次のオプションを指定できます。

@table @samp

@item -t
@itemx --trace
@itemx --tracearithmetic
実行時のレジスタをトレースします。レジスタには、GR0〜GR7という8個の汎用レジスタと、SP（スタックポインタ）、PR（プログラムレジスタ）、FR（フラグレジスタ）があります。レジストリの内容は、-32,768〜32,767の範囲の整数、#0000〜#FFFFの範囲の16進数、2進数で表示されます。文字の組に該当する場合は、「 = 」のうしろに文字が表示されます。-32768〜32767の範囲の整数が表示されるので、算術演算の結果を確認する場合に使えます。

@item -T
@itemx --tracelogical
@option{-t}と同じく、実行時のレジスタをトレースします。@option{-t}と異なり0〜65,535の範囲の整数を表示するので、論理演算の結果を確認する場合に使えます。

@item -d
@itemx --dump
メモリの内容をすべて表示します。

@item -M <MEMORYSIZE>
@itemx --memorysize <MEMORYSIZE>
実行時のメモリサイズ@option{<MEMORYSIZE>}を0〜65,535の範囲で指定します。指定しない場合、メモリサイズは512です。

@item -C <CLOCKS>
@itemx --clocks <CLOCKS>
実行時のクロック周波数@option{<CLOCKS>}を0より大きい整数で指定します。指定しない場合、クロック周波数は5,000,000です。

@item -h
@itemx --help
@command{comet2}の使用方法を表示して終了します。
@end table

@node dumpword
@section @command{dumpword}

@pindex dumpword
@cindex dumpword

@command{dumpword}は、引数として指定された数値を、整数、#0000〜#FFFFの範囲の16進数、2進数で表示します。文字の組に該当する場合は、「 = 」のうしろに文字が表示されます。引数は、10進数または先頭に「#」の付いた16進数で指定します。表示される整数は、オプションにより-32,768〜32,767または0〜65,535の範囲です。オプションなしの場合は、-32,768〜32,767です。

@example
$ @command{dumpword 10}
@end example

引数で指定できる1つだけです。引数が指定されない場合は、使い方を表示して終了します。複数の引数を指定した場合、2番目以降の引数は無視されます。

@unnumberedsubsec オプション

@command{dumpword}は、次のオプションを指定できます。

@table @samp

@item -a
@itemx --arithmetic
出力される整数の範囲を-32,768〜32,767にします。オプションなしの場合と同じです。

@item -l
@itemx --logical
出力される整数の範囲を0〜65,535にします。

@item -h
@itemx --help
@command{dumpword}の使用方法を表示して終了します。
@end table

@bye
