;;; 10進数の整数を表す文字列を数値に変換
;;; 数値の範囲は、0から65535
;;; 入力 GR1: 文字列を格納するメモリーの先頭アドレス
;;;     GR2: 文字列の長さ。最大5けた
;;; 出力 GR3: 数値
;;;           文字列が最大長より大きい場合と数値以外の場合は、GR3は#FFFF、OFは1
;;;           数値以外の場合、OFは1
;;; 依存プログラム: MULL
STR2L   START
        PUSH    0,GR1
        PUSH    0,GR2
        PUSH    0,GR4
        PUSH    0,GR5
        PUSH    0,GR6
        PUSH    0,GR7
        XOR     GR3,GR3         ; GR3の初期化
        AND     GR2,GR2         ; GR2 = 0の場合、OVへジャンプ
        JZE     OV              ; ↓
        CPL     GR2,=5          ; GR2 > 5の場合、OVへジャンプ
        JPL     OV              ; ↓
        XOR     GR4,GR4         ; GR4: インデックスの初期化
        LD      GR5,GR1         ; GR5 <- GR1
        LD      GR6,GR2         ; GR6 <- GR2
        XOR     GR1,GR1         ; GR1の初期化
STOL    LD      GR1,GR5         ; GR1に、入力文字列中の次の桁を格納
        ADDL    GR1,GR4         ; ↓
        LD      GR1,0,GR1       ; ↓
        LD      GR7,ZERO        ; GR1 < '0'の場合、FINへジャンプ
        CPL     GR1,GR7         ; ↓
        JMI     FIN             ; ↓
        LD      GR7,NINE        ; GR1 > '9'の場合、FINへジャンプ
        CPL     GR7,GR1         ; ↓
        JMI     FIN             ; ↓
        SUBL    GR1,ZERO        ; GR1の文字を、対応する数値に変換
        ADDL    GR3,GR1
        JOV     FIN
        LAD     GR4,1,GR4       ; GR4 <- GR4 + 1
        CPL     GR4,GR6         ; GR4 = GR6の場合、ループ脱出
        JZE     FIN             ; ↓
MUL10   LAD     GR2,10          ; GR2:10進数の 10
        LD      GR1,GR3         ; GR1 <- GR3
        CALL    MULL            ; MULLを呼び出し、GR3 <- GR1 * GR2
        JUMP    STOL            ; ループ終端
OV      LAD     GR7,1           ; オーバーフロー発生
        SRL     GR7,1           ; ↓
FIN     POP     GR7
        POP     GR6
        POP     GR5
        POP     GR4
        POP     GR2
        POP     GR1
        RET
ZERO    DC      '0'
NINE    DC      '9'
        END
;;; 0〜65535の範囲にある正数のかけ算（筆算方式）を行う
;;; 入力 GR1:被乗数 GR2:乗数
;;; 出力 GR3:積
;;; 積が65535より大きい場合は、オーバーフロー
MULL    START
        XOR     GR3,GR3         ; GR3の初期化
        AND     GR1,GR1         ; GR1 = 0 の場合、FINへジャンプ
        JZE     FIN             ; ↓
        AND     GR2,GR2         ; GR2 = 0 の場合、FINへジャンプ
        JZE     FIN             ; ↓
        PUSH    0,GR1           ; GR1の退避
        PUSH    0,GR2           ; GR2の退避
LOOP    SRL     GR2,1           ; ループ開始。SRLを1つ右シフト
        JOV     ON              ; 乗数の最下位ビットが1の場合、ONへジャンプ
        JUMP    NEXT            ; NEXTへジャンプ
ON      ADDL    GR3,GR1         ; GR3 <- GR3 + GR1
        JOV     POST            ; GR3がオーバーフローした場合、POSTへジャンプ
NEXT    AND     GR2,GR2         ; GR2 = 0 の場合、POSTへジャンプ
        JZE     POST            ; ↓
        SLL     GR1,1           ; GR1を1つ左シフト
        JOV     POST            ; GR1がオーバーフローした場合、POSTへジャンプ
        JUMP    LOOP            ; ループ終端
POST    POP     GR2             ; GR2の復元
        POP     GR1             ; GR1の復元
FIN     RET
        END
