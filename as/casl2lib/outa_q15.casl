;; GR1に格納された値を、10進数の符号付き小数値として表示
OUTAQ15 START
        RPUSH
        LAD     GR2,10          ; GR2に10進数の「10」を格納
        XOR     GR4,GR4         ; 整数値の長さ
        XOR     GR3,GR3         ; 出力する文字を一時的に格納
        AND     GR1,GR1         ; GR1の符号をチェック
        JPL     STDN            ; ↓ GR1が正数の場合、STDNにジャンプ
        LD      GR3,='-'        ; ↓ GR1が負数の場合、「-」をSTR領域に格納
        ST      GR3,STR         ; ↓ ↓
        LAD     GR4,1,GR4       ; ↓ ↓ GR4 <- GR4 + 1
        CPA     GR1,=#8000      ; (GR1 = #8000)の場合、MINONEへジャンプ
        JZE     MINONE          ; ↓
        CALL    ABS             ; GR1を正数に変換
STDN    LD      GR3,='0'        ; 「0」をSTR領域に格納
        ST      GR3,STR,GR4     ; ↓
        AND     GR1,GR1         ; GR1が0の場合、PRTへジャンプ
        JZE     PRT             ; ↓
        LAD     GR4,1,GR4       ; ↓ GR4 <- GR4 + 1
        LD      GR3,='.'        ; 「.」をSTR領域に格納
        ST      GR3,STR,GR4     ; ↓
        LAD     GR4,1,GR4       ; ↓ GR4 <- GR4 + 1
        SLL     GR1,1           ; GR1を1回左シフト
;; GR1の内容を小数値と見なし、10進数の文字列に変換してSTRに格納
TODIG   AND     GR1,GR1         ; GR1が0の場合は、ループを脱出
        JZE     PRT             ; ↓
        CALL    MULL            ; GR1とGR2の、積をGR1、オーバーフロー値をGR3に格納
        LD      GR1,GR0         ; GR0をGR1にコピー
        ADDA    GR3,='0'        ; GR1を文字に変換
        ST      GR3,STR,GR4     ; (STR + GR4) <- GR1
        LAD     GR4,1,GR4       ; GR4 <- GR4 + 1
        JUMP    TODIG           ; ループ
;; GR1 = -1の場合
MINONE  LD      GR1,='1'        ; GR1が#8000の場合、-1を出力
        ST      GR1,STR,GR4     ; (STR + GR4) <- GR1
        LAD     GR4,1,GR4       ; GR4 <- GR4 + 1
        JUMP    PRT             ; ↓
;; 値を出力
PRT     ST      GR4,LEN         ; LEN <- GR4
        OUT     STR,LEN         ; ↓
        RPOP
        RET
STR     DS      20
LEN     DS      1
        END

;;; GR1を符号付き整数とみなし、絶対値に変換
;;; 入力 GR1: -32768から32767の整数
;;; 出力 GR1: 入力された整数の絶対値
;;;       OF: 入力されたGR1が-32768の場合、1
;;;       SF: 入力されたGR1が負数(-32767〜-1)の場合、1
ABS     START
        AND     GR1,GR1         ; GR1が0以上の場合は、FINへジャンプ
        JPL     FIN             ; ↓
        JZE     FIN             ; ↓
        XOR     GR1,ALLON       ; GR1のビットを反転
        ADDA    GR1,ONE         ; GR1に1を追加
        JOV     FIN             ; 足し算でオーバーフローの場合は、OF:1を保持してFINへジャンプ
        CPL     GR1,ALLON       ; SF:1を設定
FIN     RET
ONE     DC      1
ALLON   DC      #FFFF
        END
;;; 0〜65535の範囲にある正数のかけ算（筆算方式）を行う
;;; 入力 GR1:被乗数 GR2:乗数
;;; 出力 GR0:積の下位WORD GR3:積の上位WORD
;;; 積が65535より大きい場合は、オーバーフロー
MULL    START
        PUSH    0,GR4
        PUSH    0,GR5
        XOR     GR0,GR0         ; 積
        XOR     GR3,GR3         ; 上位word
        XOR     GR5,GR5         ; 上位wordの一時値
        AND     GR1,GR1         ; (GR1 = 0)の場合、終了
        JZE     CHKOV           ; ↓
        AND     GR2,GR2         ; (GR2 = 0)の場合、終了
        JZE     CHKOV           ; ↓
        LAD     GR4,1           ; 対象ビット
LOOP    PUSH    0,GR4           ; ループ先頭。GR2のビット中でGR4が示すビットが0の場合、NEXTへジャンプ
        AND     GR4,GR2         ; ↓
        POP     GR4             ; ↓
        JZE     NEXT1           ; ↓
        ADDL    GR3,GR5         ; GR3 <- GR3 + GR5
        ADDL    GR0,GR1         ; GR0 <- GR0 + GR1
        JOV     AHB1            ; GR0がオーバーフローした場合、AHB1へジャンプ
        JUMP    NEXT1           ; ↓
AHB1    LAD     GR3,1,GR3       ; GR3 <- GR3 + 1
NEXT1   SLL     GR4,1           ; GR4を1回左シフト
        JOV     CHKOV           ; ↓
        SLL     GR5,1           ; GR5を1回左シフト
        CPL     GR4,GR2         ; (GR4 > GR2)の場合、CHKOVへジャンプ
        JPL     CHKOV           ; ↓
        SLL     GR1,1           ; GR1を1回左シフト
        JOV     AHB2            ; GR1がオーバーフローした場合、AHBへジャンプ
        JUMP    NEXT2           ; ↓
AHB2    LAD     GR5,1,GR5       ; GR5 <- GR5 + 1
NEXT2   JUMP    LOOP            ; ループ終端
CHKOV   AND     GR3,GR3         ; GR3 = 0の場合、終了
        JZE     FIN             ; ↓
        LAD     GR4,#FFFF       ; GR3 <> 0の場合、オーバーフロー
        SLL     GR4,1           ; ↓
FIN     POP     GR5
        POP     GR4
        RET
        END
