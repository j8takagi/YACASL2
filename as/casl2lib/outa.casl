;;; GR1に格納された値を、10進数の整数値（-32768〜32767）として表示
OUTA    START
        RPUSH
        LAD     GR2,10          ; GR2に10進数の「10」を格納。
        LAD     GR0,0           ; GR0 <- 0
        LAD     GR4,0           ; 負数フラグ。GR1が負数の場合、GR4は1
        LAD     GR5,0           ; 整数値の長さ
        AND     GR1,GR1         ; GR1をテスト
        JZE     ZPRT            ; GR1が0の場合、ZPRTにジャンプ
        JPL     STI             ; GR1が正数の場合、STIにジャンプ
        LAD     GR4,1           ; GR1が負数の場合、GR4をオン
        CALL    ABS             ;                  GR1を正数に変換
STI     CPL     GR1,GR2         ; ループ先頭。(GR1 < GR2)の場合は、ループ脱出
        JMI     STLST           ; ↓
        CALL    DIVL            ; GR1とGR2の、商をGR0、剰余をGR3に格納
        LD      GR1,GR3         ; GR1にGR3をコピー
        LD      GR1,NCHAR,GR1   ; GR1を文字に変換
        ST      GR1,STR,GR5     ; (STR + GR5) <- GR1
        LAD     GR5,1,GR5       ; GR5 <- GR5 + 1
        LD      GR1,GR0         ; GR0をGR1にコピー
        JUMP    STI             ; ループ終端
STLST   LD      GR1,NCHAR,GR1   ; GR1を文字に変換
        ST      GR1,STR,GR5     ; (STR + GR5) <- GR1
        LAD     GR5,1,GR5       ; GR5 <- GR5 + 1
        AND     GR4,GR4         ; 正数の場合
        JZE     PRT             ; ↓
        LD      GR1,='-'        ; 負数の場合、「-」をSTR領域に格納
        ST      GR1,STR,GR5     ; (STR + GR5) <- GR1
        LAD     GR5,1,GR5       ; GR5 <- GR5 + 1
        JUMP    PRT             ; PRTにジャンプ
ZPRT    LD      GR1,NCHAR       ; 「0」をSTR領域に格納
        ST      GR1,STR,GR5     ; (STR + GR5) <- GR1
        LAD     GR5,1,GR5       ; GR5 <- GR5 + 1
PRT     ST      GR5,LEN         ; LEN <- GR5
        LD      GR2,LEN         ; GR2にLENの値を格納
        LAD     GR1,STR         ; GR1に文字列のアドレスを格納
        CALL    REV             ; 文字列を逆順に並べ替え
        OUT     STR,LEN         ; 文字列を出力
        RPOP
        RET
STR     DS      17
LEN     DS      1
NCHAR   DC      '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        END
;;; GR1を符号付き整数とみなし、絶対値に変換
;;; 入力 GR1: -32768から32767の整数
;;; 出力 GR1: 入力された整数の絶対値
;;;       OF: 入力されたGR1が-32768の場合、1
;;;       SF: 入力されたGR1が負数(-32767〜-1)の場合、1
ABS     START
        AND     GR1,GR1         ; GR1が0以上の場合は、FINへジャンプ
        JPL     FIN             ; ↓
        JZE     FIN             ; ↓
        XOR     GR1,ALLON       ; GR1のビットを反転
        ADDA    GR1,ONE         ; GR1に1を追加
        JOV     FIN             ; 足し算でオーバーフローの場合は、OF:1を保持してFINへジャンプ
        CPL     GR1,ALLON       ; SF:1を設定
FIN     RET
ONE     DC      1
ALLON   DC      #FFFF
        END
;;; 0〜65535の範囲にある正数の割算（筆算方式）を行う
;;; 入力 GR1:被除数 GR2:除数
;;; 出力 GR0:商 GR3:剰余
;;; (GR2 = 0)の場合、GR0 GR3とも0になり、オーバーフロー
DIVL    START
        PUSH    0,GR1
        PUSH    0,GR2
        PUSH    0,GR4
        XOR     GR0,GR0         ; GR0:商 初期化
        XOR     GR3,GR3         ; GR3:剰余 初期化
        AND     GR2,GR2         ; (GR2 = 0)の場合、DIVZEROへジャンプ
        JZE     DIVZERO         ; ↓
        AND     GR1,GR1         ; (GR1 = 0)の場合、FINへジャンプ
        JZE     FIN             ; ↓
        ST      GR2,Y           ; YにGR2の初期値を保存
        LAD     GR4,1           ; GR4:対象ビットのインデックス 初期化
SL      CPL     GR2,GR1         ; ループ先頭。(GR2 > GR1)の場合、LOOPへループ脱出
        JPL     LOOP            ; ↓
        SLL     GR4,1           ; GR4を1回左シフト
        ST      GR2,TMP         ; GR2の値をTMPに退避
        SLL     GR2,1           ; GR2を1回左シフト
        JOV     YOV             ; オーバーフローの場合は、YOVへジャンプ
        JUMP    SL              ; ループ終端
YOV     LD      GR2,TMP         ; GR2の値をTMPから復元
        SRL     GR4,1           ; GR4を1回右シフト
        JUMP    LPIN            ; LPINへジャンプ
LOOP    SRL     GR4,1           ; ループ先頭。GR4を1回右シフト
        JZE     SETMOD          ; (GR4 = 0)の場合、SETMODへループ脱出
        SRL     GR2,1           ; GR2を1回右シフト
        CPL     GR1,Y           ; (GR1 < Y)の場合、SETMODへループ脱出
        JMI     SETMOD          ; ↓
        CPL     GR1,GR2         ; (GR1 < GR2)の場合、ループ先頭へジャンプ
        JMI     LOOP            ; ↓
LPIN    SUBL    GR1,GR2         ; GR1 <- GR1 - GR2
        ADDL    GR0,GR4         ; GR0 <- GR0 + GR4
        JUMP    LOOP            ; ループ終端
DIVZERO LAD     GR3,#8000       ; 強制的にオーバーフローを発生させ、GR3 <- 0
        SLL     GR3,1           ; ↓
        JUMP    FIN             ; FIN へジャンプ
SETMOD  LD      GR3,GR1         ; GR3 <- GR1。剰余の設定
FIN     POP     GR4
        POP     GR2
        POP     GR1
        RET
Y       DS      1
TMP     DS      1
        END
;;; メモリー上にある指定されたアドレス、長さの文字列を逆順に並べ替える
;;;     例: 12345 -> 54321、54321- -> -12345
;;; 入力 GR1:文字列のアドレス GR2:文字列の長さ
;;; 出力 （同上）
REV     START
        RPUSH
        LAD     GR3,0           ; GR3の初期化
PU      CPL     GR3,GR2         ; ループ先頭。(GR3 = GR2)の場合、ループ脱出
        JZE     NEXT            ; ↓
        LD      GR4,GR1         ; GR4 <- GR1
        ADDL    GR4,GR3         ; GR4 <- GR4 + GR3
        LD      GR5,0,GR4       ; GR5 <- GR4アドレスの値
        PUSH    0,GR5           ; GR5をプッシュ
        LAD     GR3,1,GR3       ; GR3 <- GR3 + 1
        JUMP    PU              ; ループ終端
NEXT    LAD     GR3,0           ; GR3の初期化
PO      CPL     GR3,GR2         ; ループ先頭。(GR3 = GR2)の場合、ループ脱出
        JZE     FIN             ; ↓
        POP     GR5             ; GR5にポップ
        LD      GR4,GR1         ; GR4にGR1の値をコピー
        ADDL    GR4,GR3         ; GR4 <- GR4 + GR3
        ST      GR5,0,GR4       ; GR4のアドレス <- GR5の値
        LAD     GR3,1,GR3       ; GR3 <- GR3 + 1
        JUMP    PO              ; ループ終端
FIN     RPOP
        RET
        END
